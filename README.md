# Data Structures and Algorithm Cheat Sheets

### Defintions
- Algorithm: method for solving a problem.
- Data structure: method to store information
#### Goal
- You need to always search for the fastest way in an algorithm. If you solved something in *O(n)* and it can be solved in *O(log n)* then you must do that. 

Therefore, you need to know the time complexity of each of those data structures, if the data structure takes less time than another then it's probably better to use that.

- Remember, you have a big problem and all you need to is to solve the sub problems which will eventually solve the big problem.



## Fundamentals
* [Bits And Bytes](/fundamentals/bits_bytes.md)
* [Big-O Notation](/fundamentals/big_o_notation.md)
* [Recursion](/fundamentals/recursion.md)

## Algorithms
* [Divide and Conquer](/algorithms/divide_and_conquer.md)

## Data Structures
* [Arrays](/data_structures/arrays.md)
* [Graphs](/data_structures/graphs.md)
* [Hash Tables](/data_structures/hash_tables.md)
* [Heaps](/data_structures/heaps.md)
* [Linked Lists](/data_structures/linked_lists.md)
* [Queues](/data_structures/queue.md)
* [Stacks](/data_structures/stack.md)
* [Trees](/data_structures/trees.md)
* [Binary Trees](/data_structures/binary_trees.md)
* [Red Black Trees](/data_structures/red_black_trees.md)
* [AVL Trees](/data_structures/avl_trees.md)
* [Trie](/data_structures/trie.md)
* [Tree Traversal](/data_structures/tree_traversal.md)
* [Graphs part 2](/data_structures/graphs2.md)

## Searching
* [Breadth First Search](/searching/breadth_first_search.md)
* [Depth First Search](/searching/depth_first_search.md)
* [Binary Search](/searching/binary_search.md)

## Sorting
* [Bubble Sort](/sorting/bubblesort.md)
* [Merge Sort](/sorting/mergesort.md)
* [Quick Sort](/sorting/quicksort.md)
* [Insertion Sort](/sorting/insertionsort.md)

## Dynamic Programming
* [Dynamic Programming](/sorting/dynamic_programming.md)

## Notes
* [Notes](/notes/notes.md)

## Helpful links

* https://visualgo.net/en
* https://www.bigocheatsheet.com/
* https://www.youtube.com/watch?v=-9sHvAnLN_w&ab_channel=RobEdwards

## Other Info For Interviews
- STAR Method
- [Amortized constant time](https://yourbasic.org/algorithms/amortized-time-complexity-analysis/)
- [name server](https://kinsta.com/knowledgebase/what-is-a-nameserver/)
- [What happens when you hit url in your browser](https://medium.com/@maneesha.wijesinghe1/what-happens-when-you-type-an-url-in-the-browser-and-press-enter-bb0aa2449c1a)
- [Regarding insertion at end in dynamic array](https://stackoverflow.com/questions/22597945/time-complexity-of-dynamic-arrays)

## Key terms

Amortized Constant time: Amortized analysis is used for algorithms that have expensive operations that happen only rarely. For example dynamic array (arraylist since it's backed by an array), whenever you reach the end of an array, then you need to double it's size and move all the elements to the new array. After that adding new elements will be O(1).

## Leetcode lists to do

- https://seanprashad.com/leetcode-patterns/
- https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU





